import os
import pandas as pd
import streamlit as st
from tkinter import Tk, filedialog, messagebox
import io  # Para capturar a saída de df.info()

# Definindo algumas cores suaves para as mensagens
SUCCESS_COLOR = "background-color: #e9f7ef; color: #2d6a4f;"  # Verde claro para sucesso
WARNING_COLOR = "background-color: #fff3cd; color: #856404;"  # Amarelo suave para alertas
ERROR_COLOR = "background-color: #f8d7da; color: #721c24;"    # Vermelho suave para erros

# Função para selecionar múltiplos diretórios com Tkinter
def select_directories():
    root = Tk()
    root.withdraw()  # Oculta a janela principal do Tkinter
    messagebox.showinfo("Bem-vindo", "Bem-vindo ao seletor de diretórios!")
    
    directories = []
    while True:
        directory = filedialog.askdirectory(title="Selecione um diretório")
        if directory:
            directories.append(directory)
            msg = f"Diretório selecionado: {directory}\n\nDeseja selecionar mais algum diretório?"
            if not messagebox.askyesno("Selecionar mais", msg):
                break
        else:
            break
    
    root.destroy()  # Fecha o contexto do Tkinter
    return directories

# Função para listar todos os arquivos CSV em um diretório e seus subdiretórios
def get_all_csv_files(directory):
    csv_files = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith(".csv"):
                csv_files.append(os.path.join(root, file))
    return csv_files

# Função para carregar os diretórios usando cache do Streamlit
@st.cache_data
def load_directories():
    return select_directories()


# Função para verificar dados ausentes
def verifica_dados_ausentes(file_name, df):
    # Remover colunas indesejadas como 'Unnamed: 68'
    df_cleaned = df.drop(columns=[col for col in df.columns if 'Unnamed' in col])

    # Verificar dados ausentes
    missing_data = df_cleaned.isnull().sum()
    missing_info = missing_data[missing_data > 0]

    # Exibir a mensagem de forma mais legível
    if missing_info.empty:
        st.markdown(f"<div style='{SUCCESS_COLOR}'>Arquivo: {file_name}<br>Não foram encontrados dados ausentes.</div>", unsafe_allow_html=True)
    else:
        # Organizar os dados ausentes para uma visualização mais clara
        missing_info_formatted = missing_info.to_frame(name="Dados Ausentes")
        missing_info_formatted.index.name = 'Ano'

        # Exibir dados ausentes com estilo mais limpo
        st.markdown(f"<div style='{WARNING_COLOR}'>Arquivo: {file_name}<br>Dados Ausentes:</div>", unsafe_allow_html=True)
        st.dataframe(missing_info_formatted)

        # Exibir o total de dados ausentes
        total_missing = missing_info.sum()
        st.markdown(f"<div style='{WARNING_COLOR}'>Total de dados ausentes: {total_missing:,}</div>", unsafe_allow_html=True)

    return



# Função para verificar dados duplicados
def verifica_dados_duplicados(file_name, df):
    # Remover colunas indesejadas como 'Unnamed: 68'
    df_cleaned = df.drop(columns=[col for col in df.columns if 'Unnamed' in col])

    # Verificar dados duplicados
    duplicated_data = df_cleaned[df_cleaned.duplicated()]

    # Exibir a mensagem de forma mais legível
    if duplicated_data.empty:
        st.markdown(f"<div style='{SUCCESS_COLOR}'>Arquivo: {file_name}<br>Não foram encontrados dados duplicados.</div>", unsafe_allow_html=True)
    else:
        # Exibir dados duplicados com estilo mais limpo
        st.markdown(f"<div style='{WARNING_COLOR}'>Arquivo: {file_name}<br>Dados Duplicados:</div>", unsafe_allow_html=True)
        st.dataframe(duplicated_data)

        # Exibir o total de dados duplicados
        total_duplicated = duplicated_data.shape[0]
        st.markdown(f"<div style='{WARNING_COLOR}'>Total de dados duplicados: {total_duplicated:,}</div>", unsafe_allow_html=True)

    return


# Início do programa
if __name__ == "__main__":
    selected_dirs = load_directories()

    if not selected_dirs:
        st.warning("Nenhum diretório foi selecionado. Por favor, reinicie o aplicativo e escolha pelo menos um diretório.")
    else:
        # Usa os nomes das pastas como categorias
        directories = {os.path.basename(dir_path): dir_path for dir_path in selected_dirs}

        # Streamlit App
        st.title("Explorador de Dados Personalizado")

        # Seleção de categorias no Streamlit
        category_option = st.sidebar.selectbox(
            "Escolha a pasta:",
            list(directories.keys())
        )

        if category_option:
            selected_dir = directories[category_option]

            # Listar todos os arquivos CSV no diretório e subdiretórios
            csv_files = get_all_csv_files(selected_dir)

            if csv_files:
                file_option = st.sidebar.selectbox(
                    "Escolha um arquivo:",
                    [os.path.relpath(f, selected_dir) for f in csv_files]
                )

                if file_option:
                    file_path = os.path.join(selected_dir, file_option)

                    try:
                        df = pd.read_csv(file_path)

                        view_option = st.sidebar.radio(
                            "Escolha a visualização:",
                            ("Visualizar Dados", "Informações Gerais", "Estatísticas Descritivas", "Verificar Dados Ausentes", "Verificar Dados Duplicados")
                        )

                        if view_option == "Visualizar Dados":
                            st.dataframe(df)
                        elif view_option == "Informações Gerais":
                            st.markdown(f'<h3>Informações Gerais sobre: {file_option}</h3>', unsafe_allow_html=True)
                            
                            # Informações básicas sobre o DataFrame
                            st.write("### Estrutura do DataFrame:")
                            st.write(f"- **Número de Linhas**: {df.shape[0]:,}".replace(",", "."))
                            st.write(f"- **Número de Colunas**: {df.shape[1]:,}".replace(",", "."))
                            st.write(f"- **Uso de Memória**: {df.memory_usage(deep=True).sum() / 1024:.2f} KB")

                            # Tipos de Dados e Contagem de Valores Não Nulos
                            st.write("### Tipos de Dados e Valores Não Nulos:")
                            info_df = pd.DataFrame({
                                "Coluna": df.columns,
                                "Não Nulos": [f"{val:,}".replace(",", ".") for val in df.notnull().sum()],  # Formata valores
                                "Tipo de Dado": df.dtypes.astype(str)  # Converte os tipos de dados para strings
                            })
                            st.dataframe(info_df)

                            # Visualizar os primeiros registros (opcional)
                            st.write("### Primeiras Linhas do DataFrame:")
                            st.dataframe(df.head())

                        elif view_option == "Estatísticas Descritivas":
                            st.markdown(f'<h3>Estatísticas Descritivas de: {file_option}</h3>', unsafe_allow_html=True)
                            st.write(df.describe())

                        elif view_option == "Verificar Dados Ausentes":
                            st.markdown(f'<h3>Verificando Dados Ausentes em: {file_option}</h3>', unsafe_allow_html=True)
                            verifica_dados_ausentes(file_option, df)

                        elif view_option == "Verificar Dados Duplicados":
                            st.markdown(f'<h3>Verificando Dados Duplicados em: {file_option}</h3>', unsafe_allow_html=True)
                            verifica_dados_duplicados(file_option, df)

                    except Exception as e:
                        st.markdown(f"<div style='{ERROR_COLOR}'>Erro ao carregar o arquivo: {e}</div>", unsafe_allow_html=True)
            else:
                st.warning("Nenhum arquivo CSV encontrado no diretório selecionado e seus subdiretórios.")
